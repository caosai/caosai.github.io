<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Courage Me]]></title>
  <subtitle><![CDATA[Talk is cheap,show me the code!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://caosai.org.cn//"/>
  <updated>2015-08-18T14:37:44.000Z</updated>
  <id>http://caosai.org.cn//</id>
  
  <author>
    <name><![CDATA[Cao Sai]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[java BigInteger to string]]></title>
    <link href="http://caosai.org.cn/2015/08/18/java-BigInteger-to-string/"/>
    <id>http://caosai.org.cn/2015/08/18/java-BigInteger-to-string/</id>
    <published>2015-08-18T14:28:45.000Z</published>
    <updated>2015-08-18T14:37:44.000Z</updated>
    <content type="html"><![CDATA[<p>从数据库取出一个字段的值,赋值给自己的创建的变量，出现如下异常告警：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.ClassCastException</span>: java<span class="class">.math</span><span class="class">.BigInteger</span> cannot be cast to java<span class="class">.lang</span><span class="class">.String</span></span><br></pre></td></tr></table></figure></p>
<p>后来发现原来在mysql中建表的时候，设置字段的类型为bigint型<br>我在代码中要转成Integer类型的时候用到：<br>Integer.parseInt((String)map.get(vaule))；这句报错</p>
<p>具体的解决方案：通过Object封装作为中间层进行转换</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="variable">ob =</span> <span class="built_in">map</span>.get(keyField);</span><br><span class="line">Integer.parseInt(ob.<span class="built_in">toString</span>());</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>从数据库取出一个字段的值,赋值给自己的创建的变量，出现如下异常告警：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br>]]>
    </summary>
    
      <category term="ClassCastException  BigInteger String" scheme="http://caosai.org.cn/tags/ClassCastException-BigInteger-String/"/>
    
      <category term="java" scheme="http://caosai.org.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql保留关键字和表字段冲突]]></title>
    <link href="http://caosai.org.cn/2015/08/18/mysql%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%86%B2%E7%AA%81/"/>
    <id>http://caosai.org.cn/2015/08/18/mysql保留关键字和表字段冲突/</id>
    <published>2015-08-18T14:14:45.000Z</published>
    <updated>2015-08-18T14:44:28.000Z</updated>
    <content type="html"><![CDATA[<p>mysql数据库表的字段名称不能和数据库本身的保留关键字相同<br>问题：插入数据库的sql报异常，检查了好多遍没发现到底是啥原因，问题如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">6</span> ERROR [com.sdk.biz.snowfox.common.db.SaveCacheToDB] doBatchDB <span class="number">1</span> exception: </span><br><span class="line">java.sql.SQLException: You have <span class="operator">an</span> error <span class="operator">in</span> your SQL syntax; </span><br><span class="line">check <span class="operator">the</span> manual that corresponds <span class="built_in">to</span> your MySQL server <span class="built_in">version</span> <span class="keyword">for</span> <span class="operator">the</span> <span class="constant">right</span> syntax <span class="built_in">to</span> use </span><br><span class="line">near <span class="string">'desc,create_time) values('</span>t<span class="string">','</span><span class="operator">a</span><span class="string">','</span>d<span class="string">','</span>o<span class="string">','</span><span class="operator">a</span><span class="string">','</span>test<span class="string">','</span><span class="number">2015</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">19</span>:<span class="number">25</span>:<span class="number">35</span><span class="string">')'</span> <span class="keyword">at</span> <span class="built_in">line</span> <span class="number">1</span> </span><br><span class="line">Query: insert ignore <span class="keyword">into</span> testTable(ptxId,userId,txId,priceId,statusCode,desc,create_time) values(?,?,?,?,?,?,?); </span><br><span class="line">Parameters: [[t, <span class="operator">a</span>, d, o, <span class="operator">a</span>, test, <span class="number">2015</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">04</span>], [t, <span class="operator">a</span>, d, o, <span class="operator">a</span>, test, <span class="number">2015</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">19</span>:<span class="number">25</span>:<span class="number">35</span>]]</span><br><span class="line">	<span class="keyword">at</span> org.apache.commons.dbutils.AbstractQueryRunner.rethrow(AbstractQueryRunner.java:<span class="number">392</span>) ~[commons-dbutils-<span class="number">1.6</span>.jar:<span class="number">1.6</span>]</span><br><span class="line">	<span class="keyword">at</span> org.apache.commons.dbutils.QueryRunner.batch(QueryRunner.java:<span class="number">155</span>) ~[commons-dbutils-<span class="number">1.6</span>.jar:<span class="number">1.6</span>]</span><br><span class="line">	<span class="keyword">at</span> org.apache.commons.dbutils.QueryRunner.batch(QueryRunner.java:<span class="number">92</span>) ~[commons-dbutils-<span class="number">1.6</span>.jar:<span class="number">1.6</span>]</span><br><span class="line">	<span class="keyword">at</span> com.sdk.core.jdbc.DBUtils.batch(DBUtils.java:<span class="number">405</span>) ~[classes/:na]</span><br><span class="line">	<span class="keyword">at</span> com.sdk.core.jdbc.DBModel.batch(DBModel.java:<span class="number">64</span>) ~[classes/:na]</span><br></pre></td></tr></table></figure></p>
<p>仔细看上面的报错原因：You have an error in your SQL syntax，use near ‘desc,create_time)<br>sql语法错误，在desc这个字段附近。不注意还真不知道到底为啥会出现这种错误，后来在本地测试出现一样的问题。<br>找同事过来帮忙看原因也是一头雾水，后来终于发现，原因这个desc和mysql数据库中的排序关键字冲突了。</p>
<p>解决方案：1、修改字段名称desc，如desc_name，以后建表的时候要注意不要使用关键字了。<br>2、insert ignore into sdk_callback_pulzesdk(ptxId,userId,txId,priceId,statusCode,<code>desc</code>,create_time)<br> values(‘a’,’b’,’c’,’d’,’e’,’test’, ‘2015-08-14 19:21:04’)<br>注意desc和其他字段的区别，多了两个符号括起来。就是键盘上数字键的前面那个键盘上的符号（不晓得名字了）</p>
<p>总结：遇到问题，解决问题的过程是相当苦逼的，并且遇到这种坑爹的问题，更是要细心，成长的过程就是这么酸爽。下次建表的时候要长点心了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>mysql数据库表的字段名称不能和数据库本身的保留关键字相同<br>问题：插入数据库的sql报异常，检查了好多遍没发现到底是啥原因，问题如下：<br><figure class="highlight livecodeserver"><table><tr><td class=]]>
    </summary>
    
      <category term="mysql关键字冲突" scheme="http://caosai.org.cn/tags/mysql%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%B2%E7%AA%81/"/>
    
      <category term="Mysql" scheme="http://caosai.org.cn/categories/Mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Top 10 Java中Strings的常见问题]]></title>
    <link href="http://caosai.org.cn/2015/08/03/Top-10-Java%E4%B8%ADStrings%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://caosai.org.cn/2015/08/03/Top-10-Java中Strings的常见问题/</id>
    <published>2015-08-03T08:35:51.000Z</published>
    <updated>2015-08-03T09:26:30.000Z</updated>
    <content type="html"><![CDATA[<p>下面是关于Java String最常见的10个问题</p>
<h2 id="1-_如何比较String类型的变量？用“==”还是equals()?">1. 如何比较String类型的变量？用“==”还是equals()?</h2><p>简言之，“==”用于测试引用是否相等，equals()测试值是否相等。如果你想检查两个string是不是同一个对象，你需要使用equals()方法。<br>如果你知道String的intering(link)概念就更好了。</p>
<h2 id="2-_为什么说char[]比string好对于安全敏感的信息来说？">2. 为什么说char[]比string好对于安全敏感的信息来说？</h2><p>String是不可变长的，这就意味着一旦被创建，就不会改变直到垃圾回收掉。用一个数组你可以显式的更改它的元素值。用这种方式，安全敏感信息（像密码）将不会被显式在系统中。</p>
<h2 id="3-_在switch语句中可以使用string吗？">3. 在switch语句中可以使用string吗？</h2><p>从JDK1.7开始，我们可以使用string作为switch语句的条件。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java 7 </span></span><br><span class="line"><span class="keyword">switch</span>(str.toLowerCase()) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">		<span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">		<span class="keyword">value</span> = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_如何将string转换成int？">4. 如何将string转换成int？</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Integer.parseInt(<span class="string">"10"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-_如何用空格分割一个字符串？">5. 如何用空格分割一个字符串？</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String[] </span><span class="keyword">strArray </span>= aString.split(<span class="string">"\\s+"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-_substring()方法到底是干什么用的？">6. substring()方法到底是干什么用的？</h2><p>在JDK1.6中，substring()方法引用一个已经存在的string的字符数组，而不是重新创建一个。创建一个新的string代表一个新的字符数组。你可以+一个空字符串来创建一个新的string<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.substring<span class="params">(m, n)</span> + <span class="string">""</span>;</span><br></pre></td></tr></table></figure></p>
<p>这句代码将会创建一个新的字符数组来表示一个新的string，有时候这种方式会使你的代码更快，因为垃圾回收器可以收集不用的大的string并且只保留其sub string.</p>
<h2 id="7-_String_vs_StringBuffer_vs_StringBuilder">7. String vs StringBuffer vs StringBuilder</h2><p>String vs StringBuilder:StringBuilder是可变长的，这就意味着你可以在创建一个字符串后修改它。StringBuilder vs StringBuilder: StringBuffer是同步的，也就是说是线程安全的，但是比StringBuilder速度慢。</p>
<h2 id="8-_如何重复一个string？">8. 如何重复一个string？</h2><p>在Python中我们可以用一个数字就可以重复一个string。Java中，我们可以使用Apache的StringUtils.repeat()方法。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"adcs"</span>;</span><br><span class="line"><span class="keyword">String</span> repeated = StringUtils.repeat(<span class="built_in">str</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="9-_如何将字符串转换成日期类型？">9. 如何将字符串转换成日期类型？</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str <span class="subst">=</span> <span class="string">"Sep 17, 2013"</span>;</span><br><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> <span class="subst">=</span> <span class="literal">new</span> SimpleDateFormat(<span class="string">"MMMM d, yy"</span>, <span class="built_in">locale</span><span class="built_in">.</span>ENGLISH)<span class="built_in">.</span>parse(str);</span><br></pre></td></tr></table></figure>
<h2 id="10-_如何计数一个char在一个string中出现的次数？">10. 如何计数一个char在一个string中出现的次数？</h2><p>使用Apache的StringUtils类的方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = StringUtils.countMatches(<span class="string">"111222"</span>, <span class="string">"1"</span>);</span><br></pre></td></tr></table></figure></p>
<p><a href="www.programcreek.com/2013/09/top-10-faqs-of-java-strings/">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面是关于Java String最常见的10个问题</p>
<h2 id="1-_如何比较String类型的变量？用“==”还是equals()?">1. 如何比较String类型的变量？用“==”还是equals()?</h2><p>简言之，“==”用于测试引用是否相等，]]>
    </summary>
    
      <category term="string" scheme="http://caosai.org.cn/tags/string/"/>
    
      <category term="Top 10 Series" scheme="http://caosai.org.cn/categories/Top-10-Series/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LittleSummry]]></title>
    <link href="http://caosai.org.cn/2015/08/03/LittleSummry/"/>
    <id>http://caosai.org.cn/2015/08/03/LittleSummry/</id>
    <published>2015-08-03T08:18:52.000Z</published>
    <updated>2015-08-13T15:59:26.000Z</updated>
    <content type="html"><![CDATA[<p>2015年转眼间已经过了一大半了，生活继而有了很大的变化，而不是改善，当初为了自己所谓的梦想和追求，走了出来，虽说不后悔，却也有些伤感。一方面在收支上直接跟财政挂钩，搞了个财政赤字出来。另一方面在学习上，虽然学习了很多东西，实际上并没有想象中学到的多而且深入。理想和现实之间总有无法逾越的鸿沟，即使计划的总体安排是这样，但是并没有起到太多决定性的作用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年转眼间已经过了一大半了，生活继而有了很大的变化，而不是改善，当初为了自己所谓的梦想和追求，走了出来，虽说不后悔，却也有些伤感。一方面在收支上直接跟财政挂钩，搞了个财政赤字出来。另一方面在学习上，虽然学习了很多东西，实际上并没有想象中学到的多而且深入。理想和现实之间]]>
    </summary>
    
      <category term="summry" scheme="http://caosai.org.cn/tags/summry/"/>
    
      <category term="summry life" scheme="http://caosai.org.cn/categories/summry-life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Top 10 Java常见的Exceptions]]></title>
    <link href="http://caosai.org.cn/2015/07/20/Top-10-Java%E5%B8%B8%E8%A7%81%E7%9A%84Exceptions/"/>
    <id>http://caosai.org.cn/2015/07/20/Top-10-Java常见的Exceptions/</id>
    <published>2015-07-20T13:14:15.000Z</published>
    <updated>2015-07-20T14:02:22.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章总结了关于Java Exceptions 10个最常被问的问题</p>
<h2 id="1-_Checked_vs_UnChecked">1. Checked vs UnChecked</h2><p>简言之，检查异常必须在一个方法中被显式捕获，或者在方法的throws从句中被声明。非检查时异常是由于除数为0、空指针异常等问题导致的。非检查时异常特别重要，因为你希望其他使用你的API的开发者知道如何处理这些异常。<br>例如，IOException是一种常见的检查时异常，运行时异常是一种非检查时异常。在读余下的文章之前你可以看下<a href="http://www.programcreek.com/2009/02/diagram-for-hierarchy-of-exception-classes/" target="_blank" rel="external">Java Exception Hierarchy Diagram</a></p>
<h2 id="2-_管理异常的最佳实践">2. 管理异常的最佳实践</h2><p>如果一个Exception可以被合理的处理，那么它就应该被caught，否则就应该被thrown抛出。</p>
<h2 id="3-_为什么在try中声明的变量不能在catch和finally语句块的中被调用？">3. 为什么在try中声明的变量不能在catch和finally语句块的中被调用？</h2><p>下面的代码中，字符串s在try块中被声明，不能被用在catch从句中。如下代码不能通过编译。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"path"</span>);</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);</span><br><span class="line">	String s = <span class="string">"insideTry"</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">	e.printStactTrace();</span><br><span class="line">	System.out.<span class="keyword">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因是你不知道在try语句块中Exception什么时候被抛出。对于一些特殊的例子来说，异常很有可能会在对象声明之前被抛出。</p>
<h2 id="4-_为什么Double-parseDouble(null)和Integer-parseInt(null)抛出不同的异常?">4. 为什么Double.parseDouble(null)和Integer.parseInt(null)抛出不同的异常?</h2><p>首先，它们确实抛出不同的异常。这是JDK的问题，主要是它们是不同的开发人员开发的，不用多想。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//throws java.lang.NumberFormatException: null</span></span><br><span class="line"><span class="keyword">Double</span>.parseDouble(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//throws java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-_Java中常见的运行时异常">5. Java中常见的运行时异常</h2><p>这里给出一部分，IllegalArgumentException，ArrayIndexOutBoundsException<br>它们可以用于如下语句条件不满足的时候。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"obj can not be null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-_我们可以在一个catch从句中捕捉多个Exception吗？">6. 我们可以在一个catch从句中捕捉多个Exception吗？</h2><p>答案是肯定的。只要这些异常类在类的继承中都继承同一个父类，你可以只用父类就可以了。</p>
<h2 id="7-_Java中构造函数可以抛出异常吗？">7. Java中构造函数可以抛出异常吗？</h2><p>答案是肯定的，构造函数是一种特殊的函数。</p>
<h2 id="8-_在finally从句中抛出异常。">8. 在finally从句中抛出异常。</h2><p>做下面的处理是合法的<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> mani(String[] args) &#123;</span><br><span class="line">	<span class="keyword">File</span> file1 = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"path1"</span>);</span><br><span class="line">	<span class="keyword">File</span> file2 = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"path2"</span>);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(file2);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是要有更好的代码可读性，你应该把嵌入式的try-catch块包起来作为一种新方法，然后将方法调用放在finally一个子句中。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> mani(String[] args) &#123;</span><br><span class="line">	<span class="keyword">File</span> file1 = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"path1"</span>);</span><br><span class="line">	<span class="keyword">File</span> file2 = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"path2"</span>);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		methodThrowException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-_在finally语句块中可以用return关键字吗？">9. 在finally语句块中可以用return关键字吗？</h2><p>可以。</p>
<h2 id="10-_为什么开发者默认处理异常？">10. 为什么开发者默认处理异常？</h2><pre><code>有这么多的时间段类似的代码段发生。如果正确处理异常是非常重要的，为什么开发人员一直这样做？
</code></pre><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	....</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="literal">e</span>) &#123;</span><br><span class="line">	<span class="literal">e</span>.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略虽然很容易。频繁发生并不意味着正确性。</p>
<p><a href="http://www.programcreek.com/2013/10/top-10-questions-about-java-exceptions/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章总结了关于Java Exceptions 10个最常被问的问题</p>
<h2 id="1-_Checked_vs_UnChecked">1. Checked vs UnChecked</h2><p>简言之，检查异常必须在一个方法中被显式捕获，或者在方法的throw]]>
    </summary>
    
      <category term="Exceptions" scheme="http://caosai.org.cn/tags/Exceptions/"/>
    
      <category term="Top 10 Series" scheme="http://caosai.org.cn/categories/Top-10-Series/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Top 10 Java中常用于Array的方法]]></title>
    <link href="http://caosai.org.cn/2015/07/16/Top-10-Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E4%BA%8EArray%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://caosai.org.cn/2015/07/16/Top-10-Java中常用于Array的方法/</id>
    <published>2015-07-16T15:26:36.000Z</published>
    <updated>2015-07-16T16:00:18.000Z</updated>
    <content type="html"><![CDATA[<p>下面是经常在Java Array中用到的10个方法。在StackOverFlow上被提出最多的问题。</p>
<h2 id="1-_声明一个数组">1. 声明一个数组</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>[] aArray = <span class="keyword">new</span> <span class="built_in">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">String</span>[] bArray = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>&#125;;</span><br><span class="line"><span class="built_in">String</span>[] cArray = <span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-_打印一个数组">2. 打印一个数组</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">String intArrayString = Arrays.<span class="keyword">toString</span>(intArray);</span><br><span class="line">System.<span class="keyword">out</span>.println(intArray);</span><br><span class="line"><span class="comment">// [I@7150bd4d</span></span><br><span class="line">System.<span class="keyword">out</span>.println(intArrayString);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//foreach</span></span><br><span class="line"><span class="keyword">for</span>(int <span class="keyword">n</span> : intArray) &#123;</span><br><span class="line">	System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="keyword">n</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-_用array创建一个list">3. 用array创建一个list</h2><p><strong>Arrays.asList(stringArray)</strong>传入一个数组，返回一个list<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>[] stringArray = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span> &#125;;</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;(Arrays.asList(stringArray));</span><br><span class="line">System.out.<span class="built_in">println</span>(arrayList);</span><br><span class="line"><span class="comment">// [a, b, c, d, e]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-_连接两个数组(首尾连接)">4. 连接两个数组(首尾连接)</h2><p>用到apache一个jar包   commons-lang3-3.4.jar<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] intArray2 = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);</span><br><span class="line"><span class="comment">// combinedIntArray &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-_数组中插入分割字符">5. 数组中插入分割字符</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// containing the provided list of elements</span></span><br><span class="line"><span class="comment">// Apache common lang</span></span><br><span class="line"><span class="keyword">String</span> j = StringUtils.<span class="built_in">join</span>(<span class="keyword">new</span> <span class="keyword">String</span>[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;, <span class="string">"|"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(j);</span><br><span class="line"><span class="comment">// a| b| c</span></span><br></pre></td></tr></table></figure>
<h2 id="6-_ArrayList_转换_Array">6. ArrayList 转换 Array</h2><p>思路：用到List.toArray(array)方法<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>[] stringArray = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span> &#125;;</span><br><span class="line">ArrayList&lt;<span class="keyword">String</span>&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;(Arrays.asList(stringArray));</span><br><span class="line"><span class="comment">//创建一个和list的大小一致的空的数组</span></span><br><span class="line"><span class="keyword">String</span>[] stringArr = <span class="keyword">new</span> <span class="keyword">String</span>[arrayList.<span class="built_in">size</span>()];</span><br><span class="line"><span class="comment">//list 2 array</span></span><br><span class="line">arrayList.toArray(stringArr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> s : stringArr)</span><br><span class="line">	System.out.<span class="built_in">println</span>(s);</span><br></pre></td></tr></table></figure></p>
<h2 id="7-_Array转换Set">7. Array转换Set</h2><p>set的构造函数可传入一个集合<br>  array to list  ;  new HsahSet(list)<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set是无序的</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="built_in">String</span>&gt;(Arrays.asList(stringArray));</span><br><span class="line">System.out.println(<span class="literal">set</span>);</span><br><span class="line"><span class="comment">//[d, e, b, c, a]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-_反转Array">8. 反转Array</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">ArrayUtils.<span class="keyword">reverse</span>(intArray);</span><br><span class="line">System.out.<span class="keyword">println</span>(Arrays.toString(intArray));</span><br><span class="line"><span class="comment">//[5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<h2 id="9-_数组中删除一个元素">9. 数组中删除一个元素</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//create a new array</span></span><br><span class="line"><span class="keyword">int</span>[] removed = ArrayUtils.removeElement(intArray, <span class="number">3</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(Arrays.toString(removed));</span><br></pre></td></tr></table></figure>
<h2 id="10-_检查数组中是否包含某个值">10. 检查数组中是否包含某个值</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span> &#125;;</span><br><span class="line"><span class="keyword">boolean</span> b = Arrays.<span class="keyword">asList</span>(stringArray).contains(<span class="string">"a"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(b);</span><br><span class="line"><span class="comment">//return true</span></span><br><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> a = Arrays.<span class="keyword">asList</span>(numbers).contains(<span class="number">1</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>();</span><br><span class="line"><span class="comment">//return false;</span></span><br></pre></td></tr></table></figure>
<p>上述String[]返回true，然而int[]却返回false。原因是Arrays.asList(array)这个方法的返回值类型。<br>当array是int类型的时候，返回的是List<int[]>，而不是List<integer>。所以传入的值不会和int[]相等的。<br>此方法 不适用于int[]。</integer></int[]></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面是经常在Java Array中用到的10个方法。在StackOverFlow上被提出最多的问题。</p>
<h2 id="1-_声明一个数组">1. 声明一个数组</h2><figure class="highlight dart"><table><tr><td cla]]>
    </summary>
    
      <category term="Array" scheme="http://caosai.org.cn/tags/Array/"/>
    
      <category term="Top 10 Series" scheme="http://caosai.org.cn/categories/Top-10-Series/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中equals()和hashCode()的契约]]></title>
    <link href="http://caosai.org.cn/2015/07/12/Java%E4%B8%ADequals-%E5%92%8ChashCode-%E7%9A%84%E5%A5%91%E7%BA%A6/"/>
    <id>http://caosai.org.cn/2015/07/12/Java中equals-和hashCode-的契约/</id>
    <published>2015-07-12T14:56:18.000Z</published>
    <updated>2015-07-12T15:50:20.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/avatar/java-hashcode.png" alt="Alt text"><br>Java的父类 java.lang.Object 有两个很重要的方法被定义如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="function"><span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line">public int <span class="function"><span class="title">hashCode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>它们已经被证明非常重要去理解，特别当用户自定义的对象被add到Maps中。然后，即使是高级开发者有时候也不知道如何合理的使用这两个方法。这篇文章中，我首先举一个经常犯的错误的例子，并解释hashCode和equals是如何起作用的。</p>
<h2 id="1-_一个常见的错误">1. 一个常见的错误</h2><p>常见的错误如下例子<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class Apple &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> Apple(<span class="keyword">String</span> <span class="built_in">color</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.<span class="built_in">color</span> = <span class="built_in">color</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> obj) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Apple))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;	</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">color</span>.equals(((Apple) obj).<span class="built_in">color</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		Apple a1 = <span class="keyword">new</span> Apple(<span class="string">"green"</span>);</span><br><span class="line">		Apple a2 = <span class="keyword">new</span> Apple(<span class="string">"red"</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//hashMap stores apple type and its quantity</span></span><br><span class="line">		<span class="keyword">HashMap</span>&lt;Apple, Integer&gt; m = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Apple, Integer&gt;();</span><br><span class="line">		m.put(a1, <span class="number">10</span>);</span><br><span class="line">		m.put(a2, <span class="number">20</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(m.<span class="built_in">get</span>(<span class="keyword">new</span> Apple(<span class="string">"green"</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，一个green苹果对象被成功的存在一个HashMap中，但是当在map中查询此对象的时候，这个对象没有被找到。程序结果是null。然而我们可以确定的是在debugger中该对象确实存在HashMap中。<br><img src="/avatar/hashCode-and-equals-contract.png" alt="Alt text"></p>
<h2 id="2-_问题是由hashCode()引起的">2. 问题是由hashCode()引起的</h2><p>这个问题是由于没有重写hashCode()方法。hashCode和equals中的契约是这样的：</p>
<ol>
<li>如果两个对象相等，它们必须有相同的hashcode值。</li>
<li>如果两个对象有相同的hashcode值，它们可能相等也可能不相等。</li>
</ol>
<p>Map背后的思想是能找比线性搜索更快的找到一个对象。使用散列键值来定位对象有两步过程。map内部存储对象作为一个数组的数组。第一个数组的索引就是键的hashCode的值。位于第二个数组通过线性搜索根据equals()来判断该对象是否被找到。</p>
<p>对象类的默认实现了hashcode()方法并返回不同的整数对于不同的对象来说。因此，在上面的例子中，不同的对象（即使同一类型）都有不同的hashCode值。</p>
<p>hashcode就像是一个序列的仓库存储，不同的东西可以存储在不同的仓库中。如果你把材料组织到不同的地方，而不是同一个仓库，那就更有效了。所以这是平均分配的hashCode值的一个很好的实践。（虽然不是主要的观点）。</p>
<p>解决方案就是在类中添加hashCode()方法，这里我只是使用color字符串的长度做示范。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.color.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.programcreek.com/2011/07/java-equals-and-hashcode-contract/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/avatar/java-hashcode.png" alt="Alt text"><br>Java的父类 java.lang.Object 有两个很重要的方法被定义如下：<br><figure class="highlight stylus"><tab]]>
    </summary>
    
      <category term="hashCode" scheme="http://caosai.org.cn/tags/hashCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Top关于Java中Map的9种常见问题]]></title>
    <link href="http://caosai.org.cn/2015/07/08/Top%E5%85%B3%E4%BA%8EJava%E4%B8%ADMap%E7%9A%849%E7%A7%8D%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://caosai.org.cn/2015/07/08/Top关于Java中Map的9种常见问题/</id>
    <published>2015-07-08T15:16:46.000Z</published>
    <updated>2015-07-12T14:49:28.000Z</updated>
    <content type="html"><![CDATA[<p>总的来说，Map是一种集合的数据结构有key-value对组成，每一个key可以在Map中出现一次。这篇文章总结了Java中Map最常用的9种使用方法。为了简单起见，我将在例子中使用泛型。因此我只使用Map而不使用具体的Map。但是你可以假设K和V都实现了Comparable接口。</p>
<h2 id="0-_Map2List_Map转化成List">0. Map2List Map转化成List</h2><p>Java中，Map接口提供三种集合：key集合、value结合、和key-value结合。它们都可以转化成一个List通过一个构造器或者addAll()方法。下面的代码片段展示了如何使用构造器创建通过Map创建一个ArrayList。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keyList</span></span><br><span class="line"><span class="built_in">List</span> keyList <span class="subst">=</span> ArrayList(<span class="built_in">map</span><span class="built_in">.</span>keySet());</span><br><span class="line"><span class="comment">//valueList</span></span><br><span class="line"><span class="built_in">List</span> valueList <span class="subst">=</span> ArrayList(<span class="built_in">map</span><span class="built_in">.</span>valueSet());</span><br><span class="line"><span class="comment">//entryList key-value set</span></span><br><span class="line"><span class="built_in">List</span> entryList <span class="subst">=</span> ArrayList(<span class="built_in">map</span><span class="built_in">.</span>entrySet());</span><br></pre></td></tr></table></figure>
<h2 id="1-_在Map中遍历每一个Entry">1. 在Map中遍历每一个Entry</h2><p>通过一个键值对迭代遍历一个Map是最基本的操作。在Java，键值对存储在Map中被称为Map.Entry。Map.entrySet()返回一个键值对的集合，因此要通过一个Map的每一个entry是最有效的方式来遍历map</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">for</span>(<span class="preprocessor">Entry</span> <span class="preprocessor">entry</span> : <span class="preprocessor">map</span>.entrySet()) &#123;</span><br><span class="line">	K key = <span class="preprocessor">entry</span>.getKey()<span class="comment">;</span></span><br><span class="line">	V value = <span class="preprocessor">entry</span>.getValue()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK1.5以前还可以一下方式遍历Map</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Iterator </span><span class="keyword">it </span>= <span class="preprocessor">map</span>.entrySet().<span class="keyword">iterator();</span><br><span class="line"></span><span class="label">while</span>(<span class="keyword">it.hasNext()) </span>&#123;</span><br><span class="line">	<span class="preprocessor">Entry</span> <span class="preprocessor">entry</span> = <span class="keyword">it.next();</span><br><span class="line"></span>	K key = <span class="preprocessor">entry</span>.getKey()<span class="comment">;</span></span><br><span class="line">	V value = <span class="preprocessor">entry</span>.getValue()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-_根据key在Map中排序">2. 根据key在Map中排序</h2><p>根据key排序Map是一个经常用到的操作。一个方法是将Map.Entry放进List中，使用一个比较器Comparator来排序value。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList(<span class="built_in">map</span>.entrySet());</span><br><span class="line">Collections.sort(<span class="built_in">list</span>,<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">	@<span class="function">Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry e1, Entry e2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> e1.getKey().compareTo(e2.getKey());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>另外一种方法是使用排好序的Map，可以根据key值进行自动排序。因此所有的key值必须要实现Comparable接口或者可以被一个Comparator接受。<br>一种实现了SortMap的类是TreeMap。它的构造器可以接受一个Comparator。下面的代码展示了如何将一个map转换成一个排好序的map的。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SortedMap sortMap = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(K k1, K k2)</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">return</span> k1.<span class="title">compareTo</span><span class="params">(k2)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">sortMap.putAll(map);</span><br></pre></td></tr></table></figure>
<h2 id="3-_根据value在Map中排序">3. 根据value在Map中排序</h2><p>将Map变成一个list然后排序也是可以的，不同的是我们比较Entry.getValue().下面的代码和上面几乎一样。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList(<span class="built_in">map</span>.entrySet());</span><br><span class="line">Collections.sort(<span class="built_in">list</span>,<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">	@<span class="function">Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry e1, Entry e2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> e1.getValue().compareTo(e2.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们仍然可以使用一个排序的Map来解决这个问题，但只有当value是唯一的时候。在这样的条件下，你可以把key-value的值反倒。这个解决方案有很强的限制，因此不推荐使用。</p>
<h2 id="4-_初始化一个静态的或者不可以变的Map">4. 初始化一个静态的或者不可以变的Map</h2><p>当你期望Map保持不变时，将它复制到一个不可改变的Map上是一个很好的做法。这种防御性的编程技术将帮助您创建不仅使用安全局，但而且线程Map也很安全。<br>初始化一个静态的、一成不变的Map，我们可以使用一个静态初始化器（如下）。这个代码的问题是，尽管Map被声明为static final，我们仍然可以在初始化之后对它进行操作，如Test.map.put(3,”three”);操作。因此它不是真的不可改变的。使用静态初始化器创建一个不变的Map，在初始化的最后一步，我们需要一个额外的匿名类并复制到一个不可修改的Map中。请参阅第二段代码。如果你运行Test.map.put(3,”three”);然后一个UnsupportedOperationException异常将会被抛出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> final Map <span class="built_in">map</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line">		<span class="built_in">map</span>.put(<span class="string">"a"</span>,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">map</span>.put(<span class="string">"b"</span>,<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> final Map <span class="built_in">map</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Map tmpMap = <span class="keyword">new</span> Map();</span><br><span class="line">		tmpMap.put(<span class="string">"a"</span>,<span class="number">3</span>);</span><br><span class="line">		tmpMap.put(<span class="string">"b"</span>,<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">map</span> = Collections.unmodifiableMap(tmpMap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Guava libraries也支持不同的初始化静态不变的Collection的方法。要了解更多关于Guava 不可变的Collection的好处，去看不可变集合的解释在Guava User Guide中。</p>
<h2 id="5-_HashMap,TreeMap,HashTable区别">5. HashMap,TreeMap,HashTable区别</h2><p>在Java中实现Map接口的三个主要实现类分别是：HashMap,TreeMap,HashTable<br>他们之间最重要的区别如下：</p>
<ol>
<li><strong>遍历的顺序</strong>。HashMap和HashTable不能保证map中元素的顺序，特别是，他们不保证随着时间的推移顺序会保持不变。但TreeMap将遍历整个条目按“自然顺序”的key值，或由一个比较器。</li>
<li><strong>key-value的规则</strong>。HashMap允许null的key或者value（只能有一个null的key，因为map中不能存在两个相同的key）。HashTable不允许null的key或者value。如果TreeMap根据自然顺序或者比较器来排序的话，它的key值不能为null，否则会抛出异常。</li>
<li><strong>同步</strong>。只有HashTable是同步的。因此如果不需要实现一个线程安全，推荐使用HashMap代替HashTable。</li>
</ol>
<h2 id="6-_具有反向视图和查询的Map">6. 具有反向视图和查询的Map</h2><p>有时候，我们需要一个key-value对的集合，这就意味着key和value都是唯一的（one-to-one Map）。这种约束可以确保可以创建一个“反向试图和查询的Map”。所以我们可以通过value去查询一个key。这种数据结构被称作双向映射的Map，不幸的是java JDK不支持。<br>    Apache Common Collections 和 Guava 提供了实现双向映射的Map类。分别称为BidiMap和BiMap。这两种都需要强制约束它们的key和value的值1:1的关系。</p>
<h2 id="7-_Map的浅拷贝">7. Map的浅拷贝</h2><p>在Java中实现Map的大部分类，提供一个拷贝其他map的构造方法。但是拷贝的过程不是同步的。那就意味着当一个线程拷贝一个map，另一个线程可能会改变它的结构。为了阻止偶然不同步的拷贝，必须提前用到Collections.synchronizedMap()。</p>
<blockquote>
<p>Map copiedMap = Collections.synchronizedMap(map);<br>另一种有趣的浅拷贝的方式是使用clone(),然而即使是Java集合框架的设计者Josh Bloch都不推荐使用这种方法。在一次讨论” constructor 和 cloning 拷贝的比较”中，他说：<br>我经常提供一个public的clone方法在创建类的时候，因为大家希望如此。这是克隆的耻辱，但它发生。…克隆是一个弱点，我认为人们应该意识到它的局限性。</p>
</blockquote>
<p>正因如此，我将不会告诉你如何使用clone()方法进行拷贝一个map。</p>
<h2 id="8-_创建一个空的Map">8. 创建一个空的Map</h2><p>如果Map是不可变的。使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> = Collections.emptyMap();</span><br></pre></td></tr></table></figure></p>
<p>否则，使用如下实现的方式。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.programcreek.com/2013/09/top-9-questions-for-java-map/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总的来说，Map是一种集合的数据结构有key-value对组成，每一个key可以在Map中出现一次。这篇文章总结了Java中Map最常用的9种使用方法。为了简单起见，我将在例子中使用泛型。因此我只使用Map而不使用具体的Map。但是你可以假设K和V都实现了Comparabl]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap vs TreeMap vs HashTable vs LinkedHashMap]]></title>
    <link href="http://caosai.org.cn/2015/07/07/HashMap-vs-TreeMap-vs-HashTable-vs-LinkedHashMap/"/>
    <id>http://caosai.org.cn/2015/07/07/HashMap-vs-TreeMap-vs-HashTable-vs-LinkedHashMap/</id>
    <published>2015-07-07T14:12:08.000Z</published>
    <updated>2015-07-07T14:53:10.000Z</updated>
    <content type="html"><![CDATA[<p>Java中Map是最重要的数据结构之一。在这篇文章中，我将说明如何使用不同类型的Map，如HashMap，TreeMap，哈希表和LinkedHashMap。</p>
<h2 id="1-_Map的概要">1. Map的概要</h2><p><img src="/avatar/MapClassHierarchy.png" alt="Alt text"></p>
<p>在Java SE中有四种经常被实现的Map类型被使用。HashMap，TreeMap，HashTable和LinkedHashMap。</p>
<pre><code><span class="bullet">* </span>HashMap是一个哈希表实现的,它的键或值是没有排序的。
<span class="bullet">* </span>TreeMap是基于红黑树结构的实现，它是按照key进行排序的。
<span class="bullet">* </span>LinkedHashMap保留插入顺序排序。
<span class="bullet">* </span>哈希表是同步的，即线程安全的，其他的与HashMap一样。它有一个同步的开销。这是HashMap应该在程序是线程安全的时候被使用的原因。
</code></pre><h2 id="2-_HashMap">2. HashMap</h2><p>如果HashMap的key值是自定义的对象，那么equals()和hashCode()方法的规定需要被遵循。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">	String <span class="built_in">color</span>;</span><br><span class="line"> </span><br><span class="line">	Dog<span class="params">(String c)</span> &#123;</span><br><span class="line">		<span class="built_in">color</span> = c;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString<span class="params">()</span>&#123;	</span><br><span class="line">		return <span class="built_in">color</span> + <span class="string">" dog"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestHashMap &#123;</span><br><span class="line">	public static void main<span class="params">(String[] args)</span> &#123;</span><br><span class="line">		HashMap&lt;Dog, Integer&gt; hashMap = new HashMap&lt;Dog, Integer&gt;<span class="params">()</span>;</span><br><span class="line">		Dog d1 = new Dog<span class="params">(<span class="string">"red"</span>)</span>;</span><br><span class="line">		Dog d2 = new Dog<span class="params">(<span class="string">"black"</span>)</span>;</span><br><span class="line">		Dog d3 = new Dog<span class="params">(<span class="string">"white"</span>)</span>;</span><br><span class="line">		Dog d4 = new Dog<span class="params">(<span class="string">"white"</span>)</span>;</span><br><span class="line"> </span><br><span class="line">		hashMap.put<span class="params">(d1, <span class="number">10</span>)</span>;</span><br><span class="line">		hashMap.put<span class="params">(d2, <span class="number">15</span>)</span>;</span><br><span class="line">		hashMap.put<span class="params">(d3, <span class="number">5</span>)</span>;</span><br><span class="line">		hashMap.put<span class="params">(d4, <span class="number">20</span>)</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//print size</span></span><br><span class="line">		System.out.println<span class="params">(hashMap.size<span class="params">()</span>)</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//loop HashMap</span></span><br><span class="line">		<span class="keyword">for</span> <span class="params">(Entry&lt;Dog, Integer&gt; entry : hashMap.entrySet<span class="params">()</span>)</span> &#123;</span><br><span class="line">			System.out.println<span class="params">(entry.getKey<span class="params">()</span>.toString<span class="params">()</span> + <span class="string">" - "</span> + entry.getValue<span class="params">()</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>4<br>white dog - 5<br>black dog - 15<br>red dog - 10<br>white dog - 20</p>
</blockquote>
<p>注意，我们错误的add “white dogs” 两次，但是HashMap接受了。这并没有意义的，因为现在我们很困惑有多少只white dogs在HashMap中。</p>
<p>Dog类必须定义如下所示：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">	<span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"> </span><br><span class="line">	Dog(<span class="keyword">String</span> c) &#123;</span><br><span class="line">		<span class="built_in">color</span> = c;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((Dog) o).<span class="built_in">color</span>.equals(<span class="keyword">this</span>.<span class="built_in">color</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span>.length();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> toString()&#123;	</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span> + <span class="string">" dog"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在输出的结果：</p>
<blockquote>
<p>3<br>red dog - 10<br>white dog - 20<br>black dog - 15</p>
</blockquote>
<p>原因是HashMap不允许两个相同的元素。默认情况下，该hashcode()和equals()方法在对象类实现的被使用。默认hashcode()方法return不同的对象不同的整数返回值，equals()方法只返回true仅当两个引用指向同一个对象。看看hashcode()和equals()的约定是不是符合你的预期。</p>
<h2 id="3-_TreeMap">3. TreeMap</h2><p>TreeMap是按key值排序的。让我们先来看一下下面的例子来理解“按key排序”的思路。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">	<span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"> </span><br><span class="line">	Dog(<span class="keyword">String</span> c) &#123;</span><br><span class="line">		<span class="built_in">color</span> = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((Dog) o).<span class="built_in">color</span>.equals(<span class="keyword">this</span>.<span class="built_in">color</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span>.length();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> toString()&#123;	</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span> + <span class="string">" dog"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class TestTreeMap &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		Dog d1 = <span class="keyword">new</span> Dog(<span class="string">"red"</span>);</span><br><span class="line">		Dog d2 = <span class="keyword">new</span> Dog(<span class="string">"black"</span>);</span><br><span class="line">		Dog d3 = <span class="keyword">new</span> Dog(<span class="string">"white"</span>);</span><br><span class="line">		Dog d4 = <span class="keyword">new</span> Dog(<span class="string">"white"</span>);</span><br><span class="line"> </span><br><span class="line">		TreeMap&lt;Dog, Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;Dog, Integer&gt;();</span><br><span class="line">		treeMap.put(d1, <span class="number">10</span>);</span><br><span class="line">		treeMap.put(d2, <span class="number">15</span>);</span><br><span class="line">		treeMap.put(d3, <span class="number">5</span>);</span><br><span class="line">		treeMap.put(d4, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;Dog, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(entry.getKey() + <span class="string">" - "</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Exception in thread “main” java.lang.ClassCastException: collection.Dog cannot be &gt; cast to java.lang.Comparable<br>at java.util.TreeMap.put(Unknown Source)<br>at collection.TestHashMap.main(TestHashMap.java:35)</p>
</blockquote>
<p>从TreeMap是按key排序的，key的对象必须能够相互比较，这就是为什么它必须实现Comparable接口。例如，您将使用字符串作为键，因为字符串实现了Comparable接口。</p>
<p>修改Dog类让它具有可比性</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Dog implements Comparable&lt;Dog&gt;&#123;</span><br><span class="line">	<span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">size</span>;</span><br><span class="line"> </span><br><span class="line">	Dog(<span class="keyword">String</span> c, <span class="built_in">int</span> s) &#123;</span><br><span class="line">		<span class="built_in">color</span> = c;</span><br><span class="line">		<span class="built_in">size</span> = s;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> toString()&#123;	</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span> + <span class="string">" dog"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> compareTo(Dog o) &#123;</span><br><span class="line">		<span class="keyword">return</span>  o.<span class="built_in">size</span> - <span class="keyword">this</span>.<span class="built_in">size</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class TestTreeMap &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		Dog d1 = <span class="keyword">new</span> Dog(<span class="string">"red"</span>, <span class="number">30</span>);</span><br><span class="line">		Dog d2 = <span class="keyword">new</span> Dog(<span class="string">"black"</span>, <span class="number">20</span>);</span><br><span class="line">		Dog d3 = <span class="keyword">new</span> Dog(<span class="string">"white"</span>, <span class="number">10</span>);</span><br><span class="line">		Dog d4 = <span class="keyword">new</span> Dog(<span class="string">"white"</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">		TreeMap&lt;Dog, Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;Dog, Integer&gt;();</span><br><span class="line">		treeMap.put(d1, <span class="number">10</span>);</span><br><span class="line">		treeMap.put(d2, <span class="number">15</span>);</span><br><span class="line">		treeMap.put(d3, <span class="number">5</span>);</span><br><span class="line">		treeMap.put(d4, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;Dog, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(entry.getKey() + <span class="string">" - "</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>red dog - 10<br>black dog - 15<br>white dog - 20</p>
</blockquote>
<p>在这种情况下，它是根据key排序的，即Dog的size属性值。<br>如果”Dog d4 = new Dog(“white”, 10);” 被这句话替代 “Dog d4 = new Dog(“white”, 40);”, 输出结果将会是:</p>
<blockquote>
<p>white dog - 20<br>red dog - 10<br>black dog - 15<br>white dog - 5</p>
</blockquote>
<p>原因是，现在使用的方法compareto()比较TreeMap的key值。不同Dog的size不同！</p>
<h2 id="4-_HashTable">4. HashTable</h2><p>来自Java Doc<br>HashMap类大致相当于HashTable，除了它是不同步的，允许有空值之外。</p>
<h2 id="5-_LinkedHashMap">5. LinkedHashMap</h2><p>LinkedHashMap是HashMap的子类。这意味着它继承了HashMap的特点。此外，链表保留了插入顺序的排序。</p>
<p>让我们用相同的代码使用LinkedHashMap替换HashMap。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">	<span class="keyword">String</span> <span class="built_in">color</span>;</span><br><span class="line"> </span><br><span class="line">	Dog(<span class="keyword">String</span> c) &#123;</span><br><span class="line">		<span class="built_in">color</span> = c;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((Dog) o).<span class="built_in">color</span>.equals(<span class="keyword">this</span>.<span class="built_in">color</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span>.length();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> toString()&#123;	</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">color</span> + <span class="string">" dog"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class TestHashMap &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"> </span><br><span class="line">		Dog d1 = <span class="keyword">new</span> Dog(<span class="string">"red"</span>);</span><br><span class="line">		Dog d2 = <span class="keyword">new</span> Dog(<span class="string">"black"</span>);</span><br><span class="line">		Dog d3 = <span class="keyword">new</span> Dog(<span class="string">"white"</span>);</span><br><span class="line">		Dog d4 = <span class="keyword">new</span> Dog(<span class="string">"white"</span>);</span><br><span class="line"> </span><br><span class="line">		LinkedHashMap&lt;Dog, Integer&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;Dog, Integer&gt;();</span><br><span class="line">		linkedHashMap.put(d1, <span class="number">10</span>);</span><br><span class="line">		linkedHashMap.put(d2, <span class="number">15</span>);</span><br><span class="line">		linkedHashMap.put(d3, <span class="number">5</span>);</span><br><span class="line">		linkedHashMap.put(d4, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;Dog, Integer&gt; entry : linkedHashMap.entrySet()) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(entry.getKey() + <span class="string">" - "</span> + entry.getValue());</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>red dog - 10<br>black dog - 15<br>white dog - 20</p>
</blockquote>
<p>不同的是，如果我们使用HashMap的输出结果顺序和插入的顺序是不一定一致的。</p>
<blockquote>
<p>red dog - 10<br>white dog - 20<br>black dog - 15</p>
</blockquote>
<p><a href="http://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java中Map是最重要的数据结构之一。在这篇文章中，我将说明如何使用不同类型的Map，如HashMap，TreeMap，哈希表和LinkedHashMap。</p>
<h2 id="1-_Map的概要">1. Map的概要</h2><p><img src="/avatar]]>
    </summary>
    
      <category term="Map的区别" scheme="http://caosai.org.cn/tags/Map%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[remove以.bak结尾的文件]]></title>
    <link href="http://caosai.org.cn/2015/07/07/remove%E4%BB%A5-bak%E7%BB%93%E5%B0%BE%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://caosai.org.cn/2015/07/07/remove以-bak结尾的文件/</id>
    <published>2015-07-07T14:00:02.000Z</published>
    <updated>2015-07-07T14:06:18.000Z</updated>
    <content type="html"><![CDATA[<p>使用UltraEdit编辑器的时候，产生了好多.bak结尾的备份文件。<br>一个一个的删除掉又比较费时，没啥意义，就想了个办法写个小程序来帮我做喽。<br>程序很简单，涉及到文件的路径和文件的递归遍历这两点。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> FileUtils &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		String filePath = <span class="string">"D:/test/_posts"</span>;</span><br><span class="line">		String suffix = <span class="string">".bak"</span>;</span><br><span class="line">		removeSomeFiles(filePath, suffix);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 删除以指定格式结尾的文件如 .txt .jpg .mp3等等</span><br><span class="line">	 * @param filePath 目录或文件的路径</span><br><span class="line">	 * @param suffix   文件结尾的格式</span><br><span class="line">	 * @throws IOException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> removeSomeFiles(String filePath, String suffix) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">File</span> f = <span class="keyword">new</span> <span class="keyword">File</span>(filePath);</span><br><span class="line">		<span class="keyword">if</span>(!f.isDirectory()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(f.getName().endsWith(suffix)) </span><br><span class="line">				f.<span class="keyword">delete</span>();</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">File</span>[] list = f.listFiles();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">File</span> <span class="keyword">file</span> : list) &#123;</span><br><span class="line">				removeSomeFiles(<span class="keyword">file</span>.getCanonicalPath(), suffix);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用UltraEdit编辑器的时候，产生了好多.bak结尾的备份文件。<br>一个一个的删除掉又比较费时，没啥意义，就想了个办法写个小程序来帮我做喽。<br>程序很简单，涉及到文件的路径和文件的递归遍历这两点。</p>
<figure class="highlight gr]]>
    </summary>
    
      <category term="removeFiles" scheme="http://caosai.org.cn/tags/removeFiles/"/>
    
      <category term="Java Tools" scheme="http://caosai.org.cn/categories/Java-Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单的TreeSet例子]]></title>
    <link href="http://caosai.org.cn/2015/07/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84TreeSet%E4%BE%8B%E5%AD%90/"/>
    <id>http://caosai.org.cn/2015/07/06/一个简单的TreeSet例子/</id>
    <published>2015-07-06T15:43:01.000Z</published>
    <updated>2015-07-06T16:00:18.000Z</updated>
    <content type="html"><![CDATA[<p>下面是一个非常简单的TreeSet的例子。从这个简单的例子中我们可以得知：</p>
<ul>
<li>TreeSet是有序的</li>
<li>如何遍历TreeSet</li>
<li>如何检查空</li>
<li>如何检索第一个/最后一个元素</li>
<li>如何删除元素</li>
</ul>
<p>如果你想了解更多关于Java Collection的内容，你可以查看<a href="http://www.programcreek.com/2009/02/the-interface-and-class-hierarchy-for-collections/" target="_blank" rel="external">Java Collection hierarchy diagram</a></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Iterator</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">TreeSet</span>;</span><br><span class="line"> </span><br><span class="line">public class <span class="type">TreeSetExample</span> &#123;</span><br><span class="line"> </span><br><span class="line">   public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Tree Set Example!\n"</span>);</span><br><span class="line">	<span class="type">TreeSet</span>&lt;<span class="type">Integer</span>&gt; tree = new <span class="type">TreeSet</span>&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">	tree.add(<span class="number">12</span>);</span><br><span class="line">	tree.add(<span class="number">63</span>);</span><br><span class="line">	tree.add(<span class="number">34</span>);</span><br><span class="line">	tree.add(<span class="number">45</span>);</span><br><span class="line"> </span><br><span class="line">	// here it test it's sorted, <span class="number">63</span> <span class="keyword">is</span> the last element. see output below</span><br><span class="line">	<span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span> = tree.<span class="keyword">iterator</span>();</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"Tree set data: "</span>);</span><br><span class="line"> </span><br><span class="line">	// <span class="type">Displaying</span> the <span class="type">Tree</span> <span class="type">set</span> data</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="keyword">iterator</span>.next() + <span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line"> </span><br><span class="line">	// <span class="type">Check</span> empty <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line">	<span class="keyword">if</span> (tree.isEmpty()) &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"Tree Set is empty."</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Tree Set size: "</span> + tree.size());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	// <span class="type">Retrieve</span> first data <span class="keyword">from</span> tree <span class="type">set</span></span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"First data: "</span> + tree.first());</span><br><span class="line"> </span><br><span class="line">	// <span class="type">Retrieve</span> last data <span class="keyword">from</span> tree <span class="type">set</span></span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Last data: "</span> + tree.last());</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (tree.remove(<span class="number">45</span>)) &#123; // remove element by value</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Data is removed from tree set"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Data doesn't exist!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"Now the tree set contain: "</span>);</span><br><span class="line">	<span class="keyword">iterator</span> = tree.<span class="keyword">iterator</span>();</span><br><span class="line"> </span><br><span class="line">	// <span class="type">Displaying</span> the <span class="type">Tree</span> <span class="type">set</span> data</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="keyword">iterator</span>.next() + <span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Now the size of tree set: "</span> + tree.size());</span><br><span class="line"> </span><br><span class="line">	// <span class="type">Remove</span> all</span><br><span class="line">	tree.clear();</span><br><span class="line">	<span class="keyword">if</span> (tree.isEmpty()) &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"Tree Set is empty."</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Tree Set size: "</span> + tree.size());</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Tree Set Example!</p>
<p>Tree set data: 12 34 45 63<br>Tree Set size: 4</p>
<p>First data: 12<br>Last data: 63</p>
<p>Data is removed from tree set</p>
<p>Now the tree set contain: 12 34 63<br>Now the size of tree set: 3</p>
<p>Tree Set is empty.</p>
</blockquote>
<p><a href="http://www.programcreek.com/2009/02/a-simple-treeset-example/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面是一个非常简单的TreeSet的例子。从这个简单的例子中我们可以得知：</p>
<ul>
<li>TreeSet是有序的</li>
<li>如何遍历TreeSet</li>
<li>如何检查空</li>
<li>如何检索第一个/最后一个元素</li>
<li>如何删除元]]>
    </summary>
    
      <category term="TreeSet" scheme="http://caosai.org.cn/tags/TreeSet/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashSet vs TreeSet vs LinkedHashSet]]></title>
    <link href="http://caosai.org.cn/2015/07/06/HashSet-vs-TreeSet-vs-LinkedHashSet/"/>
    <id>http://caosai.org.cn/2015/07/06/HashSet-vs-TreeSet-vs-LinkedHashSet/</id>
    <published>2015-07-06T14:45:18.000Z</published>
    <updated>2015-07-06T15:35:14.000Z</updated>
    <content type="html"><![CDATA[<p>一个set集合不包含重复元素。这是使用set的主要原因之一。有3个常用的实现set的途径：HashSet，TreeSet和LinkedHashSet。何时使用哪一种是一个重要问题。总之，如果你需要一个快速的set，你应该使用HashSet；如果你需要一个有序集合，则使用TreeSet；如果你需要一个可以插入顺序存储的set，那么LinkedHashSet应被使用。</p>
<h2 id="1-_set的接口">1. set的接口</h2><p>Set继承Collection 接口。在一个set中，没有重复的元素。在set中的每一个元素必须是唯一的。你可以简单地将元素添加到一个集合中，重复的元素会被自动删除。</p>
<p>下图是set集合集成的树形图</p>
<p><img src="/avatar/java-collection-hierarchy.png" alt="Alt text"></p>
<h2 id="2-_HashSet_vs-_TreeSet_vs-_LinkedHashSet_之间的比较">2. HashSet vs. TreeSet vs. LinkedHashSet 之间的比较</h2><p>HashSet 使用一个 hash table 实现. 元素是无序的。添加add，删除remove，和包含contains的方法有恒定的时间复杂度O(1)。</p>
<p>TreeSet 使用一个树形结构实现（算法中的红黑树）。set中的元素是有序的，但是add、remove、contains方法的时间复杂度是O(log(n))。TreeSet提供不同的方法处理有序的set集合，像first()/last()/headSet()/tailSert()等</p>
<p>LinkedHashSet 基于HashSet和TreeSet之间。它使用一个hash table实现基于一个链表的结构，所以它提供按顺序插入到集合中，时间复杂度是O(1)</p>
<h2 id="3-_TreeSet的例子">3. TreeSet的例子</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span>&lt;<span class="type">Integer</span>&gt; tree = new <span class="type">TreeSet</span>&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">tree.add(<span class="number">12</span>);</span><br><span class="line">tree.add(<span class="number">63</span>);</span><br><span class="line">tree.add(<span class="number">34</span>);</span><br><span class="line">tree.add(<span class="number">45</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span> = tree.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="type">System</span>.<span class="keyword">out</span>.print(<span class="string">"Tree set data: "</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">    <span class="type">System</span>.<span class="keyword">out</span>.print(<span class="keyword">iterator</span>.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果(有序的)：</p>
<blockquote>
<p>Tree set data: 12 34 45 63 </p>
</blockquote>
<p>下面定义一个Dog类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="keyword">int</span> s</span>) </span>&#123;</span><br><span class="line">		size = s;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size + <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向TreeSet中add几组Dog对象</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Iterator</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">TreeSet</span>;</span><br><span class="line"> </span><br><span class="line">public class <span class="type">TestTreeSet</span> &#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">		<span class="type">TreeSet</span>&lt;<span class="type">Dog</span>&gt; dset = new <span class="type">TreeSet</span>&lt;<span class="type">Dog</span>&gt;();</span><br><span class="line">		dset.add(new <span class="type">Dog</span>(<span class="number">2</span>));</span><br><span class="line">		dset.add(new <span class="type">Dog</span>(<span class="number">1</span>));</span><br><span class="line">		dset.add(new <span class="type">Dog</span>(<span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">		<span class="type">Iterator</span>&lt;<span class="type">Dog</span>&gt; <span class="keyword">iterator</span> = dset.<span class="keyword">iterator</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">			<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="keyword">iterator</span>.next() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成功，但是运行时出现错误</p>
<blockquote>
<p>Exception in thread “main” java.lang.ClassCastException: collection.<strong>Dog cannot be cast to java.lang.Comparable</strong><br>    at java.util.TreeMap.put(Unknown Source)<br>    at java.util.TreeSet.add(Unknown Source)<br>    at collection.TestTreeSet.main(TestTreeSet.java:22)</p>
</blockquote>
<p>原因： TreeSet是有序的集合，Dog对象需要实现<strong>java.lang.Comparable’s compareTo()</strong> 方法</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> Comparable&lt;Dog&gt;&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> Dog(<span class="keyword">int</span> s) &#123;</span><br><span class="line">		<span class="keyword">size</span> = s;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> String toString() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">size</span> + <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">compareTo</span>(Dog o) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">size</span> - o.<span class="keyword">size</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>1 2 3</p>
</blockquote>
<h2 id="4-_HashSet_例子">4. HashSet 例子</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span>&lt;<span class="type">Dog</span>&gt; dset = new <span class="type">HashSet</span>&lt;<span class="type">Dog</span>&gt;();</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">2</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">1</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">3</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">5</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">4</span>));</span><br><span class="line"><span class="type">Iterator</span>&lt;<span class="type">Dog</span>&gt; <span class="keyword">iterator</span> = dset.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="keyword">iterator</span>.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>5 3 2 1 4<br>注意结果顺序是不确定的。</p>
</blockquote>
<h2 id="5-_LinkedHashSet_例子">5. LinkedHashSet 例子</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedHashSet</span>&lt;<span class="type">Dog</span>&gt; dset = new <span class="type">LinkedHashSet</span>&lt;<span class="type">Dog</span>&gt;();</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">2</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">1</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">3</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">5</span>));</span><br><span class="line">dset.add(new <span class="type">Dog</span>(<span class="number">4</span>));</span><br><span class="line"><span class="type">Iterator</span>&lt;<span class="type">Dog</span>&gt; <span class="keyword">iterator</span> = dset.<span class="keyword">iterator</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">	<span class="type">System</span>.<span class="keyword">out</span>.print(<span class="keyword">iterator</span>.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果顺序是一定的，按照添加的先后顺序排序。</p>
<blockquote>
<p>2 1 3 5 4</p>
</blockquote>
<h2 id="6-_性能测试">6. 性能测试</h2><p>下面的测试方法是测试 三种不同的set的add方法的性能</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">	Random r = new Random<span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">	HashSet&lt;Dog&gt; hashSet = new HashSet&lt;Dog&gt;<span class="params">()</span>;</span><br><span class="line">	TreeSet&lt;Dog&gt; treeSet = new TreeSet&lt;Dog&gt;<span class="params">()</span>;</span><br><span class="line">	LinkedHashSet&lt;Dog&gt; linkedSet = new LinkedHashSet&lt;Dog&gt;<span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// start time</span></span><br><span class="line">	long startTime = System.nanoTime<span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span> &#123;</span><br><span class="line">		int x = r.nextInt<span class="params">(<span class="number">1000</span> - <span class="number">10</span>)</span> + <span class="number">10</span>;</span><br><span class="line">		hashSet.add<span class="params">(new Dog<span class="params">(x)</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// end time</span></span><br><span class="line">	long endTime = System.nanoTime<span class="params">()</span>;</span><br><span class="line">	long duration = endTime - startTime;</span><br><span class="line">	System.out.println<span class="params">(<span class="string">"HashSet: "</span> + duration)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// start time</span></span><br><span class="line">	startTime = System.nanoTime<span class="params">()</span>;</span><br><span class="line">	<span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span> &#123;</span><br><span class="line">		int x = r.nextInt<span class="params">(<span class="number">1000</span> - <span class="number">10</span>)</span> + <span class="number">10</span>;</span><br><span class="line">		treeSet.add<span class="params">(new Dog<span class="params">(x)</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// end time</span></span><br><span class="line">	endTime = System.nanoTime<span class="params">()</span>;</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println<span class="params">(<span class="string">"TreeSet: "</span> + duration)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// start time</span></span><br><span class="line">	startTime = System.nanoTime<span class="params">()</span>;</span><br><span class="line">	<span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span> &#123;</span><br><span class="line">		int x = r.nextInt<span class="params">(<span class="number">1000</span> - <span class="number">10</span>)</span> + <span class="number">10</span>;</span><br><span class="line">		linkedSet.add<span class="params">(new Dog<span class="params">(x)</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// end time</span></span><br><span class="line">	endTime = System.nanoTime<span class="params">()</span>;</span><br><span class="line">	duration = endTime - startTime;</span><br><span class="line">	System.out.println<span class="params">(<span class="string">"LinkedHashSet: "</span> + duration)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从输出的结果可以清楚的知道，HashSet的add方法花费时间最少。</p>
<blockquote>
<p>HashSet: 2244768<br>TreeSet: 3549314<br>LinkedHashSet: 2263320</p>
</blockquote>
<p>*测试虽然不精确，但能反映基本思想TreeSet慢得多因为它是排好序的。</p>
<p><img src="/avatar/hashset-treeset-linkedhashset1.png" alt="Alt text"></p>
<p><a href="http://www.programcreek.com/2013/03/hashset-vs-treeset-vs-linkedhashset/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个set集合不包含重复元素。这是使用set的主要原因之一。有3个常用的实现set的途径：HashSet，TreeSet和LinkedHashSet。何时使用哪一种是一个重要问题。总之，如果你需要一个快速的set，你应该使用HashSet；如果你需要一个有序集合，则使用Tr]]>
    </summary>
    
      <category term="set" scheme="http://caosai.org.cn/tags/set/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中检查数组中是否存在某个值的方法]]></title>
    <link href="http://caosai.org.cn/2015/07/05/Java%E4%B8%AD%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://caosai.org.cn/2015/07/05/Java中检查数组中是否存在某个值的方法/</id>
    <published>2015-07-05T14:42:42.000Z</published>
    <updated>2015-07-05T14:46:32.000Z</updated>
    <content type="html"><![CDATA[<p>检查数组中是否存在某一个值的方法有三种方式<br>    foreach：for循环<br>    Arrays.asList(arr);<br>    Set</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * java中检查一个数组中是否含有某个值的方法</span><br><span class="line"> * @author cslience</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class ArrayUtils &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//useLoop 推荐这种方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> isContainsValueLoop(<span class="keyword">String</span>[] arr, <span class="keyword">String</span> targetValue) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">String</span> s : arr) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s.equals(targetValue)) </span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//useList</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> isContainsValueList(<span class="keyword">String</span>[] arr, <span class="keyword">String</span> targetValue) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(arr).contains(targetValue);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> isContainsValueSet(<span class="keyword">String</span>[] arr, <span class="keyword">String</span> targetValue) &#123;</span><br><span class="line">		</span><br><span class="line">		Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;(Arrays.asList(arr));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">set</span>.contains(targetValue);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5,1k,10k  time complexity</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">String</span>[] arr = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>&#125;;</span><br><span class="line">		<span class="keyword">String</span> targetValue = <span class="string">"e"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> begin = System.nanoTime();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			isContainsValueLoop(arr, targetValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> cost = end - begin;</span><br><span class="line">		</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"loop cost time = "</span> + cost/<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		begin = System.nanoTime();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			isContainsValueSet(arr, targetValue);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.nanoTime();</span><br><span class="line">		</span><br><span class="line">		cost = end - begin;</span><br><span class="line">		</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"set cost time = "</span> + cost/<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		begin = System.nanoTime();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			isContainsValueList(arr, targetValue);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.nanoTime();</span><br><span class="line">		</span><br><span class="line">		cost = end - begin;</span><br><span class="line">		</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"list cost time = "</span> + cost/<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>检查数组中是否存在某一个值的方法有三种方式<br>    foreach：for循环<br>    Arrays.asList(arr);<br>    Set</p>
<figure class="highlight processing"><table><tr><td ]]>
    </summary>
    
      <category term="array contains value" scheme="http://caosai.org.cn/tags/array-contains-value/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中PrintMap]]></title>
    <link href="http://caosai.org.cn/2015/07/03/Java%E4%B8%ADPrintMap/"/>
    <id>http://caosai.org.cn/2015/07/03/Java中PrintMap/</id>
    <published>2015-07-03T15:53:25.000Z</published>
    <updated>2015-07-03T16:00:08.000Z</updated>
    <content type="html"><![CDATA[<p>给一个数组，统计某些值出现的次数，通过HashMap来处理</p>
<p>map的排序 HashMap是无序的，如果想给一个集合排序的话<br>有两种方式：<br>第一种：转换成TreeMap  ：使用比较器：按照key/value排序<br>第二种；转换成List  ：使用比较器：也可以按照key/value排序</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">import</span> java.util.Comparator;</span><br><span class="line"><span class="literal">import</span> java.util.HashMap;</span><br><span class="line"><span class="literal">import</span> java.util.<span class="built_in">Iterator</span>;</span><br><span class="line"><span class="literal">import</span> java.util.<span class="built_in">Map</span>;</span><br><span class="line"><span class="literal">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrintMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*String[] test = &#123;"a","a","a","a","b","b","c",&#125;;</span><br><span class="line">		Map&lt;String, Integer&gt; map = counterMap(test);</span><br><span class="line">		printMapForeach(map);</span><br><span class="line">		System.out.println("------------------------------");</span><br><span class="line">		printMap(map);*/</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		sortTreeMapByValue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/**</span><br><span class="line"><span class="code">	 * 统一数组中各个值出现的次数</span></span><br><span class="line"><span class="code">	 * @param strArray</span></span><br><span class="line"><span class="code">	 */</span></span></span></span><br><span class="line">	public <span class="literal">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; counterMap(<span class="built_in">String</span>[] strArray) &#123;</span><br><span class="line">		HashMap&lt;<span class="built_in">String</span>, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">String</span> a : strArray) &#123;</span><br><span class="line">			<span class="keyword">if</span>(countMap.keySet().contains(a))&#123;</span><br><span class="line">				countMap.put(a, countMap.<span class="literal">get</span>(a)+<span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				countMap.put(a, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> countMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//HashMap 无序的 无法直接排序--需要转换list  Collections.sort(list,Comparator);</span></span><br><span class="line">	public <span class="literal">static</span> <span class="keyword">void</span> sortHashMapByKey() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="literal">static</span> <span class="keyword">void</span> sortHashMapByValue() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//TreeMap 有序的  new TreeMap(new Comparator())</span></span><br><span class="line">	public <span class="literal">static</span> <span class="keyword">void</span> sortTreeMapByValue() &#123;</span><br><span class="line">		HashMap&lt;<span class="built_in">String</span>, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, Integer&gt;();</span><br><span class="line">		<span class="comment">//add a lot of entries</span></span><br><span class="line">		countMap.put(<span class="string">"a"</span>, <span class="number">10</span>);</span><br><span class="line">		countMap.put(<span class="string">"b"</span>, <span class="number">20</span>);</span><br><span class="line">		 </span><br><span class="line">		ValueComparator vc =  <span class="keyword">new</span> ValueComparator(countMap);</span><br><span class="line">		TreeMap&lt;<span class="built_in">String</span>,Integer&gt; sortedMap = <span class="keyword">new</span> TreeMap&lt;<span class="built_in">String</span>,Integer&gt;(vc);</span><br><span class="line">		 </span><br><span class="line">		sortedMap.putAll(countMap);</span><br><span class="line">		printMap(sortedMap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/**</span><br><span class="line"><span class="code">	 * 打印map</span></span><br><span class="line"><span class="code">	 * @param mp</span></span><br><span class="line"><span class="code">	 */</span></span></span></span><br><span class="line">	public <span class="literal">static</span> <span class="keyword">void</span> printMap(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; mp) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">Iterator</span>&lt;?&gt; it = mp.entrySet().iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">			<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt; pairs = (<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt;) it.next();</span><br><span class="line">			System.out.println(pairs.getKey() + <span class="string">" = "</span> + pairs.getValue());</span><br><span class="line">			it.remove();<span class="comment">//移除该元素</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/**</span><br><span class="line"><span class="code">	 * foreach 打印map</span></span><br><span class="line"><span class="code">	 * @param mp</span></span><br><span class="line"><span class="code">	 */</span></span></span></span><br><span class="line">	public <span class="literal">static</span> <span class="keyword">void</span> printMapForeach(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; mp) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt; entry : mp.entrySet()) &#123;</span><br><span class="line">			System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; base;</span><br><span class="line"></span><br><span class="line">	public ValueComparator(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; base) &#123;</span><br><span class="line">		<span class="keyword">this</span>.base = base;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	public <span class="built_in">int</span> compare(<span class="built_in">String</span> key1, <span class="built_in">String</span> key2) &#123;</span><br><span class="line">		<span class="keyword">return</span> base.<span class="literal">get</span>(key1) - base.<span class="literal">get</span>(key2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>给一个数组，统计某些值出现的次数，通过HashMap来处理</p>
<p>map的排序 HashMap是无序的，如果想给一个集合排序的话<br>有两种方式：<br>第一种：转换成TreeMap  ：使用比较器：按照key/value排序<br>第二种；转换成List  ：使]]>
    </summary>
    
      <category term="HashMap" scheme="http://caosai.org.cn/tags/HashMap/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中如何把Array转化成ArrayList]]></title>
    <link href="http://caosai.org.cn/2015/07/02/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8A%8AArray%E8%BD%AC%E5%8C%96%E6%88%90ArrayList/"/>
    <id>http://caosai.org.cn/2015/07/02/Java中如何把Array转化成ArrayList/</id>
    <published>2015-07-02T15:02:10.000Z</published>
    <updated>2015-07-02T15:39:12.000Z</updated>
    <content type="html"><![CDATA[<p>本文分析了在Stack Overflow上的问题的答案。问这个问题的人得到了很多的赞，这可以让他有权限做大量的事情在Stack Overflow。这对我来说不是很有意义，但是让我们先来看看这个问题吧。</p>
<p>**问题是：如何将下面的 数组转换成ArrayList集合？</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element<span class="keyword">[</span>]<span class="instruction"> array </span>= &#123;new<span class="function"> Element(</span>1<span class="function">)</span>,new<span class="function"> Element(</span>2<span class="function">)</span>,new<span class="function"> Element(</span>3<span class="function">)</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-_最流行和被接受的答案">1. 最流行和被接受的答案</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Element&gt; arrayList = new ArrayList&lt;Element&gt;<span class="list">(<span class="keyword">Arrays</span>.asList<span class="list">(<span class="keyword">array</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>首先，我们看下Java Doc中关于ArrayList的构造函数的描述：</p>
<pre><code>&gt; <span class="type">ArrayList</span>(<span class="type">Collection</span> &lt; ? extends E &gt; c) : <span class="type">Constructs</span> a list containing the elements <span class="keyword">of</span> the specified collection, <span class="keyword">in</span> the order they are returned by the collection's <span class="keyword">iterator</span>.
</code></pre><p>所以构造函数做了下面两件事：</p>
<ol>
<li>把Collection转换成Array</li>
<li>复制Array到ArrayList自己的备份数组“elementData”中<br>下面是ArrayList的构造器的源代码</li>
</ol>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">public ArrayList(Collection&lt;? <span class="keyword">extends</span> E&gt; c ) &#123;</span><br><span class="line">		elementData = c<span class="string">.toArray()</span>;</span><br><span class="line">		size = elementData<span class="string">.length</span>;</span><br><span class="line">		if(elementData<span class="string">.getClass()</span> != Object[]<span class="string">.class)</span> &#123;</span><br><span class="line">				elementData = Arrays<span class="string">.copyOf(elementData</span>, size, Object[]<span class="string">.class)</span>;</span><br><span class="line">		&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-_第二流行的答案">2. 第二流行的答案</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span>Element<span class="subst">&gt;</span> <span class="built_in">list</span> <span class="subst">=</span> Arrays<span class="built_in">.</span>asList(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure>
<p>这不是最好的，因为从aslist()返回list的大小是固定的。实际上返回的list是不java.util.ArrayList，而是私有静态类内部定义的java.util.Arrays。我们知道ArrayList基本实现为一个Array，从aslist()返回的list是由原来的Array返回的一个固定大小的list。这样，如果从返回的list中添加或删除元素，将抛出UnsupportedOperationException。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Element(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="class">.lang</span><span class="class">.ClassCastException</span>: java<span class="class">.util</span><span class="class">.Arrays</span><span class="variable">$ArrayList</span> cannot be cast to java<span class="class">.util</span><span class="class">.ArrayList</span></span><br><span class="line">	at collection<span class="class">.ConvertArray</span><span class="class">.main</span>(ConvertArray<span class="class">.java</span>:<span class="number">22</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-_另外一个的答案">3. 另外一个的答案</h2><p>这个答案来自于网友的评论</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Element<span class="keyword">[</span>]<span class="instruction"> array </span>= &#123;new<span class="function"> Element(</span>1<span class="function">)</span>,<span class="instruction"> new </span>Element(2<span class="function">)</span>&#125;;</span><br><span class="line">List&lt;element&gt; list =<span class="instruction"> new </span>ArrayList&lt;element&gt;(array.length<span class="function">)</span>;</span><br><span class="line">Collections.addAll(list, array<span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.programcreek.com/2013/04/how-to-convert-array-to-arraylist-in-java/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文分析了在Stack Overflow上的问题的答案。问这个问题的人得到了很多的赞，这可以让他有权限做大量的事情在Stack Overflow。这对我来说不是很有意义，但是让我们先来看看这个问题吧。</p>
<p>**问题是：如何将下面的 数组转换成ArrayList集合]]>
    </summary>
    
      <category term="Array2ArrayList" scheme="http://caosai.org.cn/tags/Array2ArrayList/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[随机生成手机号码]]></title>
    <link href="http://caosai.org.cn/2015/07/02/%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/"/>
    <id>http://caosai.org.cn/2015/07/02/随机生成手机号码/</id>
    <published>2015-07-02T13:56:31.000Z</published>
    <updated>2015-07-02T14:30:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="随机生成一个手机号码">随机生成一个手机号码</h2><p>首先说说手机号码的构成：<br>我国使用的手机号码为11位，其中各段有不同的编码方向：前3位———网络识别号；第4-7位———地区编码；第8-11位———用户号码。<br>前三位：代表不同的运营商，也就是号段。<br>        移动137、138、139 联通 132、155、156、186 电信 133、180、181、189 等<br>第4-7位：代表中国地区：也就是利用这个查询归属地的<br>后四位：随机是生成</p>
<p>了解了手机号码的构成后，生成随机的手机号就变得简单了<br>手机号 11 =  3（号段）+4（地区号）+4（随机生成4位）</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 随机生成电话号码</span><br><span class="line"> * @author cslience</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class RandomTelephoneNumber &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 随机生成某一个运营商的某些地区的号码</span><br><span class="line">	 * 手机号码共11位数字。前3位是不同的移动运营商（公司）字段。4-7位就是区域代码</span><br><span class="line">	 * carries:各种号段数组   location：区域代码数组</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> generatePhoneNumber(<span class="keyword">String</span>[] carries, <span class="keyword">String</span>[] location) &#123;</span><br><span class="line"></span><br><span class="line">		Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="comment">//随机取 号段+区域代码</span></span><br><span class="line">		<span class="built_in">int</span> carriesIndex = rand.nextInt(carries.length);</span><br><span class="line">		<span class="built_in">int</span> locationIndex = rand.nextInt(location.length);</span><br><span class="line">		<span class="comment">//随机生成后4位数</span></span><br><span class="line">		<span class="keyword">String</span>[] beforeShuffle = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>,<span class="string">"0"</span>&#125;;</span><br><span class="line">		List&lt;<span class="keyword">String</span>&gt; list = Arrays.asList(beforeShuffle);</span><br><span class="line">		Collections.shuffle(list);</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">String</span> s : list) &#123;</span><br><span class="line">			sb.<span class="built_in">append</span>(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">String</span> afterShuffle = sb.toString();</span><br><span class="line">		<span class="keyword">String</span> last4 = afterShuffle.substring(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> carries[carriesIndex] + location[locationIndex] + last4;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		<span class="keyword">String</span>[] ca = &#123;<span class="string">"138"</span>,<span class="string">"188"</span>&#125;;</span><br><span class="line">		<span class="keyword">String</span>[] lo = &#123;<span class="string">"1324"</span>,<span class="string">"1234"</span>&#125;;</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(generatePhoneNumber(ca, lo));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="随机生成一个手机号码">随机生成一个手机号码</h2><p>首先说说手机号码的构成：<br>我国使用的手机号码为11位，其中各段有不同的编码方向：前3位———网络识别号；第4-7位———地区编码；第8-11位———用户号码。<br>前三位：代表不同的运营商，也就是]]>
    </summary>
    
      <category term="随机生成手机号码" scheme="http://caosai.org.cn/tags/%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/"/>
    
      <category term="Java Tools" scheme="http://caosai.org.cn/categories/Java-Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中按行写文件的方法]]></title>
    <link href="http://caosai.org.cn/2015/07/01/Java%E4%B8%AD%E6%8C%89%E8%A1%8C%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://caosai.org.cn/2015/07/01/Java中按行写文件的方法/</id>
    <published>2015-07-01T14:37:09.000Z</published>
    <updated>2015-07-01T15:50:02.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章总结了使用相关类写文件的操作</p>
<h2 id="1-_FileOutputStream">1. FileOutputStream</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> writeFile1() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">File</span> fout = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"out.txt"</span>);</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(fout);</span><br><span class="line">		BufferedWriter br = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(fos));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				br.<span class="keyword">write</span>(<span class="string">"test"</span>);</span><br><span class="line">				br.newLine();</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中用了FileOutputStream,你可以使用FileWriter或者PrintWriter代替处理txt格式的文件操作</p>
<h2 id="2-_FileWriter">2. FileWriter</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">writeFile2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				fw.write(<span class="string">"something"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-_PrintWriter">3. PrintWriter</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">writeFile3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				pw.write(<span class="string">"something"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pw.close();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-_OutputStreamWriter">4. OutputStreamWriter</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> writeFile4() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">File</span> fout = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"out.txt"</span>);</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(fout);</span><br><span class="line">		OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				osw.<span class="keyword">write</span>(<span class="string">"something"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-_它们的区别">5. 它们的区别</h2><p>来自Java Doc</p>
<blockquote>
<p>FileWriter是写入字符文件的工具类。该类的构造函数假设默认的字符编码和默认的字节缓冲区大小是可以接受的。<br>如果需要自定义这些参数值，通过构建一个OutputStreamWriter基于FileOutputStream。</p>
<p>PrintWriter打印格式化的对象表示通过文本输出流。<br>这个类实现了所有被创建在PrintWriter中的方法。它不包含写原始字节的方法，因此程序应该使用未编码的字节流。</p>
</blockquote>
<p>主要的区别是，PrintWriter提供格式如println和printf一些额外的方法。此外，FileWriter会抛出异常以防任何一种I/O失败。<br>PrintWriter方法不抛出IOException，它们设置一个可使用checkerror()获得的boolean型flag位。PrintWriter在每个被写入的数据字节后自动调用flush。涉及到FileWriter，调用者需要注意使用flush。</p>
<p><a href="http://www.programcreek.com/2011/03/java-write-to-a-file-code-example/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章总结了使用相关类写文件的操作</p>
<h2 id="1-_FileOutputStream">1. FileOutputStream</h2><figure class="highlight gradle"><table><tr><td class="gutter]]>
    </summary>
    
      <category term="writeFile" scheme="http://caosai.org.cn/tags/writeFile/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中按行读取文件的方法]]></title>
    <link href="http://caosai.org.cn/2015/07/01/Java%E4%B8%AD%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://caosai.org.cn/2015/07/01/Java中按行读取文件的方法/</id>
    <published>2015-06-30T16:06:29.000Z</published>
    <updated>2015-07-22T15:53:54.000Z</updated>
    <content type="html"><![CDATA[<p>Java I/O的总的类的数量很多，所以很容糊涂什么时候用哪一种。下面有两个方法介绍按行读取文件的操作。</p>
<h2 id="方法一：">方法一：</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> readFile1(File fin) <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(fin);</span><br><span class="line">	<span class="comment">//Construct BufferedReader from InputStreamReader</span></span><br><span class="line">	<span class="keyword">BufferedReader</span> br = <span class="keyword">new</span> BufferReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">	<span class="keyword">String</span> <span class="built_in">line</span> = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="built_in">line</span> = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="built_in">line</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二：">方法二：</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> readFile2(File fin) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// Construct BufferedReader from FileReader</span></span><br><span class="line">	<span class="keyword">BufferedReader</span> br =<span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> FileReader(fis));</span><br><span class="line">	<span class="keyword">String</span> <span class="built_in">line</span> = <span class="keyword">null</span>;</span><br><span class="line">	While((<span class="built_in">line</span> = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="built_in">line</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下面的代码取文件路径">下面的代码取文件路径</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">use</span> . <span class="keyword">to</span> get current directory</span><br><span class="line"><span class="keyword">File</span> dir = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"."</span>);</span><br><span class="line"><span class="keyword">File</span> fin = <span class="keyword">new</span> <span class="keyword">File</span>(dir.getCanonicalPath() + <span class="keyword">File</span>.separator + <span class="string">"in.txt"</span>);</span><br><span class="line">readFile1(fin);</span><br><span class="line">readFile2(fin);</span><br></pre></td></tr></table></figure>
<p>这两个例子都是为了按行读取一个文本文件。</p>
<p>这两种方法之间的区别是用什么区构造BufferedReader。方法1使用 InputStreamReader，方法2使用有FileReader。这两者的区别是什么？</p>
<p>从Java DOC看，InputStreamReader是字节流到字符流的桥梁：它根据指定的字符集读取字节和解码为字符。InputStreamReader可以处理其他输入流，如网络连接，CLASSPATH资源，ZIP文件，等。</p>
<p>FileReader是读取字符文件的工具类。该类的构造函数假定默认的字符编码和默认的字节缓冲区的大小是合适的。FileReader 不允许你指定一个编码以外的其他平台的默认编码。因此，如果程序运行在不同的平台编码系统中，它就不是一个好的方式。</p>
<p>总之，InputStreamReader比FileReader是更安全的选择。</p>
<p>值得一提的，而不是使用/或\作为路径，你应该在不同的操作系统中总是使用File.separator可保证分隔符总是正确的。另外，所使用的路径应该是相对的，并且确保路径始终是正确的。</p>
<p>更新：</p>
<p>您还可以使用以下方法，这是自Java1.7。从本质上讲，它和方法1相同。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">"US-ASCII"</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">BufferedReader</span> reader = Files.newBufferedReader(file, charset)) &#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">line</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">line</span> = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">line</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">    System.err.format(<span class="string">"IOException: %s%n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newBufferedReader方法如下:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">BufferedReader</span> newBufferedReader(Path path, Charset cs)&#123;</span><br><span class="line"> CharsetDecoder decoder = cs.newDecoder();</span><br><span class="line"> Reader reader = <span class="keyword">new</span> InputStreamReader(newInputStream(path), decoder);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(reader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阅读类层次图也非常有助于理解那些InputStream和reader的相关概念: <a href="http://www.programcreek.com/2012/05/java-io-class-hierarchy-diagram/" target="_blank" rel="external">http://www.programcreek.com/2012/05/java-io-class-hierarchy-diagram/</a>.</p>
<p>引用: <a href="http://docs.oracle.com/javase/tutorial/essential/io/file.html" target="_blank" rel="external">http://docs.oracle.com/javase/tutorial/essential/io/file.html</a></p>
<p><a href="http://www.programcreek.com/2011/03/java-read-a-file-line-by-line-code-example/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java I/O的总的类的数量很多，所以很容糊涂什么时候用哪一种。下面有两个方法介绍按行读取文件的操作。</p>
<h2 id="方法一：">方法一：</h2><figure class="highlight processing"><table><tr><td class]]>
    </summary>
    
      <category term="readLine" scheme="http://caosai.org.cn/tags/readLine/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Comparator vs Comparable]]></title>
    <link href="http://caosai.org.cn/2015/06/29/Comparator-vs-Comparable/"/>
    <id>http://caosai.org.cn/2015/06/29/Comparator-vs-Comparable/</id>
    <published>2015-06-29T15:44:28.000Z</published>
    <updated>2015-06-29T15:48:58.000Z</updated>
    <content type="html"><![CDATA[<p>Comparable 和 Comparator 是JAVA 核心API 提供的两个接口。从它们的名字我们可以得知它们是用来比较东西的在某种意义上说。但他们到底是什么，它们之间的区别是什么呢？以下是回答这个问题的2个例子。比较两个HDTV的尺寸简单的例子。在阅读代码后，如何使用Comparable vs. Comparator就比较容易了。</p>
<h2 id="1-Comparable">1.Comparable</h2><p>一个类实现Comparable接口，以便能够比较对象本身与一些其他对象。类本身必须实现此接口以便能够比较其实例（的）。所需实现的方法compareto()。这里就是一个例子：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HDTV <span class="keyword">implements</span> Comparable&lt;HDTV&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">	<span class="keyword">private</span> String brand;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> HDTV(<span class="keyword">int</span> <span class="keyword">size</span>, String brand) &#123;</span><br><span class="line">		<span class="keyword">this</span>.<span class="keyword">size</span> = <span class="keyword">size</span>;</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> getSize() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">size</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> setSize(<span class="keyword">int</span> <span class="keyword">size</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.<span class="keyword">size</span> = <span class="keyword">size</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> String getBrand() &#123;</span><br><span class="line">		<span class="keyword">return</span> brand;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> setBrand(String brand) &#123;</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">compareTo</span>(HDTV tv) &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.getSize() &gt; tv.getSize())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getSize() &lt; tv.getSize())</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Main &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		HDTV tv1 = <span class="keyword">new</span> HDTV(<span class="number">55</span>, <span class="string">"Samsung"</span>);</span><br><span class="line">		HDTV tv2 = <span class="keyword">new</span> HDTV(<span class="number">60</span>, <span class="string">"Sony"</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (tv1.<span class="keyword">compareTo</span>(tv2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(tv1.getBrand() + <span class="string">" is better."</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(tv2.getBrand() + <span class="string">" is better."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sony is better.</p>
</blockquote>
<h2 id="2-Comparator">2.Comparator</h2><p>在某些情况下，您可能不希望更改一个类，并使其具有可比较性。在这种情况下，如果你想比较基于某些属性/字段的对象，可以使用Comparator。例如，2个人可以基础上的身高或年龄等进行比较（Comparable不能被用于这种比较）。</p>
<p>需要实现的方法是compare()。现在让我们用另一种方式来比较这些电视的大小。比较器的一个常见用途是排序。集合和数组类提供了一种使用比较器的排序方法。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"> </span><br><span class="line">class HDTV &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> brand;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> HDTV(<span class="built_in">int</span> <span class="built_in">size</span>, <span class="keyword">String</span> brand) &#123;</span><br><span class="line">		<span class="keyword">this</span>.<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> getSize() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> setSize(<span class="built_in">int</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> getBrand() &#123;</span><br><span class="line">		<span class="keyword">return</span> brand;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> setBrand(<span class="keyword">String</span> brand) &#123;</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class SizeComparator implements Comparator&lt;HDTV&gt; &#123;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> compare(HDTV tv1, HDTV tv2) &#123;</span><br><span class="line">		<span class="built_in">int</span> tv1Size = tv1.getSize();</span><br><span class="line">		<span class="built_in">int</span> tv2Size = tv2.getSize();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (tv1Size &gt; tv2Size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tv1Size &lt; tv2Size) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class Main &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		HDTV tv1 = <span class="keyword">new</span> HDTV(<span class="number">55</span>, <span class="string">"Samsung"</span>);</span><br><span class="line">		HDTV tv2 = <span class="keyword">new</span> HDTV(<span class="number">60</span>, <span class="string">"Sony"</span>);</span><br><span class="line">		HDTV tv3 = <span class="keyword">new</span> HDTV(<span class="number">42</span>, <span class="string">"Panasonic"</span>);</span><br><span class="line"> </span><br><span class="line">		ArrayList&lt;HDTV&gt; al = <span class="keyword">new</span> ArrayList&lt;HDTV&gt;();</span><br><span class="line">		al.<span class="built_in">add</span>(tv1);</span><br><span class="line">		al.<span class="built_in">add</span>(tv2);</span><br><span class="line">		al.<span class="built_in">add</span>(tv3);</span><br><span class="line"> </span><br><span class="line">		Collections.<span class="built_in">sort</span>(al, <span class="keyword">new</span> SizeComparator());</span><br><span class="line">		<span class="keyword">for</span> (HDTV a : al) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(a.getBrand());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Panasonic<br>Samsung<br>Sony</p>
</blockquote>
<p>我们经常会使用Collections.reverseorder()方法得到一个降序比较器。如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; <span class="keyword">al</span> = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">al</span>.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">al</span>.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">al</span>.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="keyword">al</span>);</span><br><span class="line">Collections.<span class="built_in">sort</span>(<span class="keyword">al</span>);</span><br><span class="line">System.out.println(<span class="keyword">al</span>);</span><br><span class="line"> </span><br><span class="line">Comparator&lt;Integer&gt; comparator = Collections.reverseOrder();</span><br><span class="line">Collections.<span class="built_in">sort</span>(<span class="keyword">al</span>,comparator);</span><br><span class="line">System.out.println(<span class="keyword">al</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<blockquote>
<p>[3,1,2]<br>[1,2,3]<br>[3,2,1]</p>
</blockquote>
<h2 id="3-什么时候使用？">3.什么时候使用？</h2><p>简单地说，一个类实现Comparable可以被比性，这意味着它的实例之间可以相互比较。<br>一个类实现Comparator将主要在两种情况下使用：1）它可以通过一个排序方法，如Collections.sort（）或Arrays.sort（），允许精确控制的排序顺序和2）它也可以被用来控制的顺序一定的数据结构，如有序集合（例如TreeSet）或排序图（例如，Treemap）。</p>
<p>例如，创建一个TreeSet。我们可以通过构造一个Comparator或使对象类可比较。</p>
<p>方法1——TreeSet（Comparator comparator）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">	Dog(<span class="keyword">int</span> s) &#123;</span><br><span class="line">		size = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dog d1, Dog d2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d1.size - d2.size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpComparable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TreeSet&lt;Dog&gt; d = <span class="keyword">new</span> TreeSet&lt;Dog&gt;(<span class="keyword">new</span> SizeComparator()); <span class="comment">// pass comparator</span></span><br><span class="line">		d.add(<span class="keyword">new</span> Dog(<span class="number">1</span>));</span><br><span class="line">		d.add(<span class="keyword">new</span> Dog(<span class="number">2</span>));</span><br><span class="line">		d.add(<span class="keyword">new</span> Dog(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法2——实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Dog</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">	Dog(<span class="keyword">int</span> s) &#123;</span><br><span class="line">		size = s;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Dog o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o.size - <span class="keyword">this</span>.size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpComparable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TreeSet&lt;Dog&gt; d = <span class="keyword">new</span> TreeSet&lt;Dog&gt;();</span><br><span class="line">		d.add(<span class="keyword">new</span> Dog(<span class="number">1</span>));</span><br><span class="line">		d.add(<span class="keyword">new</span> Dog(<span class="number">2</span>));</span><br><span class="line">		d.add(<span class="keyword">new</span> Dog(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.programcreek.com/2011/12/examples-to-demonstrate-comparable-vs-comparator-in-java/" target="_blank" rel="external">原文链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Comparable 和 Comparator 是JAVA 核心API 提供的两个接口。从它们的名字我们可以得知它们是用来比较东西的在某种意义上说。但他们到底是什么，它们之间的区别是什么呢？以下是回答这个问题的2个例子。比较两个HDTV的尺寸简单的例子。在阅读代码后，如何使]]>
    </summary>
    
      <category term="Comparator" scheme="http://caosai.org.cn/tags/Comparator/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java中开发者如何排序]]></title>
    <link href="http://caosai.org.cn/2015/06/27/java%E4%B8%AD%E5%BC%80%E5%8F%91%E8%80%85%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F/"/>
    <id>http://caosai.org.cn/2015/06/27/java中开发者如何排序/</id>
    <published>2015-06-27T15:24:05.000Z</published>
    <updated>2015-06-27T15:38:16.000Z</updated>
    <content type="html"><![CDATA[<p> 分析开源java项目的大量开源代码，我发现java开发者常用的排序方法有两种。一种是用Collections或者Arrays的sort()方法，另一种是用排好序的数据结构，例如TreeMap和TreeSet。</p>
<h2 id="使用sort()方法">使用sort()方法</h2><p>集合使用Collections.sort()方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections.sort</span></span><br><span class="line">List&lt;ObjectName&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;ObjectName&gt;();</span><br><span class="line">Collections.sort(<span class="built_in">list</span>,<span class="keyword">new</span> Comparator&lt;ObjectName&gt;() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ObjectName o1, ObjectName o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o1.toString().compareTo(o2.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>数组使用Arrays.sort()方法</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.sort</span></span><br><span class="line">ObjectName[] arr = <span class="keyword">new</span> ObjectName[<span class="number">10</span>];</span><br><span class="line">Arrays.<span class="keyword">sort</span>(arr, <span class="keyword">new</span> Comparator&lt;ObjectName&gt;() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> compare(ObjectName o1, ObjectName o2) &#123;</span><br><span class="line">		<span class="keyword">return</span> o1.toString().<span class="keyword">compareTo</span>(o2.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当集合或数据创建好了，这种方式非常简洁。</p>
<h2 id="使用排序好的数据结构">使用排序好的数据结构</h2><p>list或者set使用TreeSet排序<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet</span></span><br><span class="line">Set&lt;ObjectName&gt; sortedSet = new TreeSet&lt;ObjectName&gt;<span class="params">(new Comparator&lt;ObjectName&gt;<span class="params">()</span> &#123;</span><br><span class="line">	public int compare<span class="params">(ObjectName o1, ObjectName o2)</span> &#123;</span><br><span class="line">		return o1.toString<span class="params">()</span>.compareTo<span class="params">(o2.toString<span class="params">()</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span>;</span><br><span class="line">sortedSet.addAll<span class="params">(unsortedSet)</span>;</span><br></pre></td></tr></table></figure></p>
<p>map使用TreeMap排序,TreeMap 根据key排序</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeMap - using String.CASE_INSENSITIVE_ORDER which is a Comparator that orders Strings by compareToIgnoreCase</span></span><br><span class="line"><span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> sortedMap <span class="subst">=</span> <span class="literal">new</span> TreeMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span>(<span class="built_in">String</span><span class="built_in">.</span>CASE_INSENSITIVE_ORDER);</span><br><span class="line">sortedMap<span class="built_in">.</span>putAll(unsortedMap);</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeMap - In general, defined comparator</span></span><br><span class="line"><span class="built_in">Map</span>&lt;ObjectName, <span class="built_in">String</span>&gt; sortedMap = <span class="keyword">new</span> TreeMap&lt;ObjectName, <span class="built_in">String</span>&gt;(<span class="keyword">new</span> Comparator&lt;ObjectName&gt;() &#123;</span><br><span class="line">	public <span class="built_in">int</span> compare(ObjectName o1, ObjectName o2) &#123;</span><br><span class="line">		<span class="keyword">return</span> o1.toString().compareTo(o2.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">sortedMap.putAll(unsortedMap);</span><br></pre></td></tr></table></figure>
<p>这种方法是非常有用的,如果你想做很多关于集合的搜索操作。排序的数据结构的时间是复杂度O(logn),低于O(n)。</p>
<h2 id="不好的实例">不好的实例</h2><p>有很多不好的实例,比如使用自定义排序算法。以下面的代码为例,不仅算法不是有效的,而且它是不可读的。这种情况发生在不同形式的变化。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double t;</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">2</span>; <span class="built_in">i</span>++)</span><br><span class="line">	<span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="built_in">j</span> &lt; <span class="number">3</span>; <span class="built_in">j</span>++)</span><br><span class="line">		<span class="keyword">if</span> (r<span class="matrix">[j]</span> &lt; r<span class="matrix">[i]</span>) <span class="cell">&#123;</span><br><span class="line">			t = r[i];</span><br><span class="line">			r[i] = r[j];</span><br><span class="line">			r[j] = t;</span><br><span class="line">		&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p> 分析开源java项目的大量开源代码，我发现java开发者常用的排序方法有两种。一种是用Collections或者Arrays的sort()方法，另一种是用排好序的数据结构，例如TreeMap和TreeSet。</p>
<h2 id="使用sort()方法">使用sort(]]>
    </summary>
    
      <category term="sort" scheme="http://caosai.org.cn/tags/sort/"/>
    
      <category term="Simple Java" scheme="http://caosai.org.cn/categories/Simple-Java/"/>
    
  </entry>
  
</feed>